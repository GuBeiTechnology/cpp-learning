# 面向对象
什么是对象？
- 世间万物皆是对象，一切事物均有他的属性与行为。
- 对象是具体化的事物，把对象抽象化成相应的属性与行为集合就是类；通俗讲就是把一些有相同属性行为的事物归为一类；
- 这个类也就和程序中将的类概念是相同的。在编码中可以对类的属性进行权限控制


**类中的属性和行为统一称为成员；**
**属性也叫成员属性，成员变量；**
**类中的行为也叫成员函数，成员方法；**


类、对象、属性、变量、行为(函数)、方法(函数)

封装（Encapsulation）是一种面向对象编程的概念，它是指将数据和对数据的操作方法（即函数或方法）捆绑在一起，形成一个独立的、可复用的单元。封装可以将实现细节隐藏起来，只对外暴露必要的接口，从而提高代码的安全性和可维护性。
--------------------------------------------------来自AI生成{ChatGPT}


# C++类成员的访问权限分为：
1.公共权限public        类里类外都可以访问
2.保护权限protected     类外不可见
1.私有权限private       类外不可见
什么是类里、类外呢；
定义类的代码块就是类里，除了定义类的代码块就是类外；

# C++中struct和class的区别
默认权限的不同
struct默认权限是公共
class默认权限是私有

# 关于我对“类概念教学的想法”
我们可以用音乐风格的类比来解释C++中的“类”这个概念。就像不同类型的音乐可以被分类为摇滚、流行、古典等，C++中的不同对象也可以被归类为不同的“类”。每个“类”都有自己独特的属性和方法，就像每种音乐风格都有自己独特的特征和元素一样。通过定义一个类，我们可以创建一个新类型的对象，并在程序中使用它们执行各种任务。例如，在一个图书管理系统中，我们可以创建一个名为“Book”的类，并将每本书作为该类的一个实例进行处理。这样，我们就可以轻松地对图书进行分类、查询和管理了。

# Cmake跨平台项目构造工具
由于我是使用的Vscode进行编码学习，但是今天学着学着突然发现一个问题。
如果我把程序分文件编写，编译时我一般只是编译一个文件那么需要写分文件编译然后将他们链接起来
这个操作是很繁琐的，所以我了解到了Makefile以及更加高级的Cmake工具。
Cmake工具可以生成与操作系统和编译器兼容的构建文件
CMake使用简单的配置文件来描述项目的构建过程，这使得项目更易于维护，并且可以轻松地在不同的平台之间共享。
## Cmake的优点：

1. 跨平台性：CMake支持多种操作系统和编译器，这使得开发者可以在不同平台上使用相同的代码库。

2. 简化构建过程：CMake能够根据开发者提供的配置文件自动生成相应的构建文件，减少了手动配置和重复劳动。

3. 支持多个编译器：开发者可以通过指定不同的编译器生成对应平台上最佳性能和可移植性的代码。

4. 易于维护：使用CMake进行项目管理可以使代码更加易于维护和扩展，并且降低了出错率。

那么使用Cmake需要在需要处理的工作目录下创建一个CmakeList.txt用来告诉Cmake如何去操作
有点类似灯塔给迷雾中的船只指明方向
咳咳
1需要指明Cmake的最低版本号[除非你研究过你安装的低版本否则请填写你当前的版本号]
查询版本号的方法是
cmake --version
Cmake的语法关键字不区分大小写，只是预定义宏不能随便变更大小道理我想你应该能理解的
CMAKE_MINIMUM_REQUIRED(VERSION 3.26.4)      #貌似井号是注释

2.指明工程名称
project(XXXXXX)                             #这里就和那个庞大的IDE的工程名称类似啦

3.构建目标
add_executable(可执行程序 源文件1 源文件2  ...)   这里好像不能有，
一般上面的就够用了遇到更加复杂的留给那时候解决Bug的"我"吧！！！！

果然找到合适自己的教程才是好的
上午磨了两个番茄时间没耐心了
打了一下午游戏现在在B站上找了一期2020年的Vscode配合Cmake工具的视频瞬间清晰了

## 疑惑总结
其实如果不使用Cmake或者Makefile这一类工具也可以自己使用G++分步编译链接起来
通过与AI交流明白了Cmake这类构造工具实际上类似VirtualStudio那种大型IDE的项目管理，可以方便的**指定**编译出现的中间**文件存放位置**以及项目所使用的**编译器**与**编译的参数**
### C++编译流程
1. 预处理：将源代码中的预处理指令（例如#include和#define）展开，生成预处理后的源代码。

2. 编译：将预处理后的源代码转换成汇编代码。

3. 汇编：将汇编代码转换成机器码（二进制文件），同时生成符号表（存储变量和函数名以及其对应的地址等信息）。

4. 链接：将所有需要链接的目标文件（包括自己写的源文件和引用的库文件）进行合并，生成可执行文件。在链接过程中会根据符号表解析出各个变量和函数之间的依赖关系，并进行地址重定向等操作。

其中每个步骤都有一些具体细节需要注意不同编译器生成的文件以及实现方式不同。为了方便程序员使用，通常会使用集成开发环境（IDE）来自动化完成这些步骤，并提供调试、测试等功能。

不同编译器实现的方式不同，生成的文件也不相同。虽然C++标准规定了语言的基本特性和语法，但是对于一些细节、优化等方面，各个编译器可能采用不同的实现方式。

在生成可执行文件方面，常见的有三种格式：
Windows平台上使用PE格式（Portable Executable）
Linux平台上使用ELF格式（Executable and Linkable Format）
Mac OS X则使用Mach-O格式（Mach Object）
此外，在编译过程中还会生成一些其他类型的文件，例如调试信息文件、中间代码文件等。

需要注意的是，虽然各种编译器实现方式不同且生成文件格式也不同，但它们都应该遵循C++标准规范，并保证生成程序在运行时具有正确的行为和结果。因此，在选择编译器时，除了考虑其性能、功能等方面之外，还需要关注其是否符合标准规范并具有良好的兼容性。
### 我在使用MinGW编译使用到的参数
    g++  
    -c                  Compile and assemble, but do not link. //编译和汇编，但不链接。
    -o <file>           Place the output into <file>.          //将输出放入 <file>.

# C++函数的默认参数
在C++中，函数的默认参数只能从右往左添加。这是因为，如果一个函数的默认参数没有从右到左连续地出现，编译器将无法正确解析传递给该函数的参数。

例如，以下代码段中第二个默认参数后面没有再定义默认值：

```cpp
void foo(int x, int y = 0, int z) {
    // function body
}
```

在调用 `foo()` 函数时，你需要显式地为第三个参数提供一个值，否则编译器会产生错误。

这是因为当你调用 `foo()` 时，在语法上无法判断你是否希望将第三个参数作为默认参数（即使用默认值），还是实际提供了一个非默认值。因此，在C++中必须确保所有非末尾的函数参数都有默认值。

请注意，你可以通过指定全部的参数来避免使用任何默认参数，并且也不需要强制指定最后一个未定义的默认参数。例如：

```cpp
foo(1, 2, 3); // 正确调用
foo(1, 2);    // 正确调用
foo(1);       // 错误调用：缺少第三个参数
```

# C++对象的初始化列表

1. 初始化列表是用于构造函数中初始化类成员变量的机制。

2. 在构造函数的参数列表后面使用冒号来引入初始化列表，并在花括号内指定每个成员变量及其初始值。

3. 初始化列表必须按照声明顺序列出所有成员变量，即使它们没有显式地在构造函数的参数列表中声明。

4. 如果一个类没有定义任何构造函数，则编译器将生成一个默认构造函数，并将所有成员变量初始化为默认值（例如0或空）。

5. 如果一个类定义了至少一个构造函数，则编译器不会再自动生成默认构造函数。如果仍需要使用默认构造函数，请显式地定义它（例如，通过 `MyClass() = default;`）

6. 在某些情况下，特别是在处理类继承时，基类的构造函数也可能需要使用初始化列表来初始化其成员变量。

7. 初始化列表还可用于调用父类或其他对象的有参构造函数，在这种情况下，语法格式如下：

   ```cpp
   MyClass::MyClass(int x, int y) : BaseClass(x), otherObject(y) {
       // constructor body
   }
   ```

8. 如果一个数据成员是常量、引用类型或具有自己的默认值，则它必须在初始化列表中进行初始化，而不能在构造函数体中赋值。

9. 初始化列表通常比构造函数体更高效，因为它们允许编译器将成员变量的初始化转换为单个内存分配操作。

# C++赋值操作

1. 直接赋值

直接将一个值赋给变量，例如：

```cpp
int a = 10;
```

2. 复制赋值

使用 `=` 运算符将一个变量的值复制给另一个变量，例如：

```cpp
int a = 10;
int b = a; // 将 a 的值复制给 b
```

3. 引用赋值

使用引用（`&`）将一个变量绑定到另一个变量上，例如：

```cpp
int a = 10;
int &b = a; // 将 b 绑定到 a 上
```

此时修改 `b` 的值会同时修改 `a` 的值。

4. 移动赋值

在 C++11 中引入了移动语义，可以通过移动操作（`std::move()`）将对象转移到新的位置并同时清空原来的位置。移动操作比复制操作更加高效。例如：

```cpp
std::string str1 = "hello";
std::string str2 = std::move(str1); // 移动 str1 到 str2，并清空 str1
```

5. 置换赋值

在 C++17 中引入了置换语义，可以通过置换操作（`std::swap()`）交换两个对象的内容。与移动语义不同的是，在置换语义中交换后两个对象都保留其原有状态。例如：

```cpp
std::string str1 = "hello";
std::string str2 = "world";
std::swap(str1, str2); // 交换 str1 和 str2 的内容
```

这些赋值方式各有优缺点，根据具体的场景选择合适的方式可以提高代码效率和可读性。